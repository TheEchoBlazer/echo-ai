<script>
/* ====== DOM ====== */
const $ = s => document.querySelector(s);
const chatEl = $("#chat"), inputEl = $("#in"), sendBtn = $("#send");
const modelEl = $("#model"), loadBtn = $("#load"), statusEl = $("#status");
const rig = $("#rig"), shadow = $("#shadow"), mouth = $("#mouth");
const speakBtn = $("#speak"), voiceSel = $("#voice");

/* ====== Landing FX ====== */
let landed=false;
rig?.addEventListener('animationend', (e)=>{
  if (e.animationName === 'drop-in' && !landed){
    landed=true; rig.classList.add('land-impact'); document.getElementById('stage').classList.add('shake');
    shadow.style.opacity=.85; setTimeout(()=>document.getElementById('stage').classList.remove('shake'),260);
  }
});

/* ====== Chat UI helpers ====== */
function escapeHtml(s){return String(s).replace(/[<>&]/g,c=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[c]));}
function mdLite(t){
  const parts=String(t).split(/```/); let out="";
  for(let i=0;i<parts.length;i++){
    if(i%2===0) out+=escapeHtml(parts[i]).replace(/\n/g,"<br>");
    else{ const nl=parts[i].indexOf("\n"); let lang="txt",code=parts[i];
      if(nl!==-1){ lang=parts[i].slice(0,nl).trim()||"txt"; code=parts[i].slice(nl+1); }
      out+=`<pre class="code"><code data-lang="${lang}">${escapeHtml(code)}</code></pre>`;
    }
  } return out;
}
function addBubble(role,text){
  const row=document.createElement("div");
  row.className="row"+(role==="user"?" me":"");
  const msg=document.createElement("div");
  msg.className="msg "+(role==="user"?"mine":"theirs");
  msg.innerHTML=mdLite(text);
  row.appendChild(msg); chatEl.appendChild(row); chatEl.scrollTop=chatEl.scrollHeight;
}
function note(m){ statusEl.textContent=m; console.log("[Echo-AI]", m); }

/* ====== WebLLM Engine ====== */
let engine=null, lastReply="";
const history=[{role:"system",content:
`You are a focused coding helper for Minecraft Skript (Minehut/Purpur/1.21.x, SkBee) and Gorilla Tag/Unity 2021.3.21f1 (Photon PUN 2, PlayFab).
Return concise, copy-pasteable code blocks in triple backticks. Avoid deprecated Skript syntaxes.`}];

function engineReady(){
  if (!window.webllm){ note("WebLLM script not loaded."); return false; }
  if (!engine){ note("Load a model first."); return false; }
  return true;
}

loadBtn.addEventListener("click", async ()=>{
  if(!window.webllm){ note("WebLLM script missing. Make sure lib/web-llm.umd.min.js exists."); return; }
  const { CreateMLCEngine, prebuiltAppConfig } = window.webllm;
  const modelId = modelEl.value;
  note(`Loading ${modelId}…`);
  sendBtn.disabled = true;
  try{
    engine = await CreateMLCEngine(modelId, {
      appConfig: prebuiltAppConfig,
      useWebWorker:false,
      gpu:true
    }, (p)=> note(`${p.text} ${Math.round(p.progress*100)}%`));
    note(`Loaded ${modelId}. Type and hit Send.`);
    inputEl.focus();
    sendBtn.disabled = false;
  }catch(e){
    console.error(e);
    note(`Load error: ${e.message}`);
  }
});

/* ====== Generate with local model (robust) ====== */
async function runLocal(messages){
  // Try modern chat API first
  try{
    if (engine?.chat?.completions?.create){
      const out = await engine.chat.completions.create({
        messages,
        temperature: 0.2,
        max_tokens: 900,        // some builds want this
        max_new_tokens: 900,    // some builds expect this instead
        stream: false
      });
      const reply = out?.choices?.[0]?.message?.content ?? null;
      if (reply) return reply;
    }
  }catch(e){
    console.warn("chat.completions.create failed, falling back:", e);
  }

  // Fallback: build a plain prompt and use older generate()
  const prompt = messages.map(m => {
    const role = m.role.toUpperCase();
    return `${role}: ${m.content}`;
  }).join("\n") + "\nASSISTANT:";
  if (typeof engine?.generate === "function"){
    const out = await engine.generate(prompt, { temperature: 0.2, max_tokens: 900 });
    if (out?.output_text) return out.output_text;
    if (typeof out === "string") return out;
  }

  throw new Error("No compatible generation method found on this WebLLM build.");
}

async function send(){
  const text=inputEl.value.trim();
  if(!text){ return; }
  if(!engineReady()) return;

  inputEl.value=""; inputEl.focus(); sendBtn.disabled=true;
  addBubble("user",text); const thinkingRow = addThinking();

  try{
    const msgs=history.concat([{role:"user",content:text}]);
    const reply = await runLocal(msgs);
    history.push({role:"user",content:text});
    history.push({role:"assistant",content:reply});
    lastReply = reply;

    // replace the “…thinking…” bubble
    thinkingRow.innerHTML = mdLite(reply);

    // auto-speak
    speak(reply);
    note("Done.");
  }catch(e){
    console.error(e);
    thinkingRow.innerHTML = mdLite("**Error:** "+escapeHtml(e.message));
    note("Generation error.");
  }finally{
    sendBtn.disabled=false;
  }
}

function addThinking(){
  const row=document.createElement("div");
  row.className="row";
  const msg=document.createElement("div");
  msg.className="msg theirs";
  msg.textContent="…thinking…";
  row.appendChild(msg); chatEl.appendChild(row); chatEl.scrollTop=chatEl.scrollHeight;
  return msg;
}

sendBtn.addEventListener("click", send);
inputEl.addEventListener("keydown", e=>{ if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); send(); }});
document.querySelectorAll(".chip").forEach(ch=> ch.addEventListener("click", ()=>{ inputEl.value=ch.dataset.text; inputEl.focus(); }));

/* ====== TTS + simple lipsync ====== */
let voices=[]; let talkingTimer=null;
function loadVoices(){
  voices=speechSynthesis.getVoices().filter(v=>v.lang.startsWith('en'));
  voiceSel.innerHTML = voices.map((v,i)=>`<option value="${i}">${v.name} (${v.lang})${v.default?' — default':''}</option>`).join('');
}
loadVoices(); speechSynthesis.onvoiceschanged = loadVoices;

function speak(text){
  if(!text){ text=lastReply; }
  if(!text) return;
  speechSynthesis.cancel(); clearInterval(talkingTimer); mouth.classList.remove('talk');
  const u=new SpeechSynthesisUtterance(text);
  if(voices.length) u.voice = voices[voiceSel.value|0] || voices[0];
  u.onstart=()=>{ let open=false; talkingTimer=setInterval(()=>{ open=!open; mouth.classList.toggle('talk',open); }, 90); };
  u.onboundary=(ev)=>{ if(ev.name==='word'||ev.charIndex%5===0) mouth.classList.toggle('talk'); };
  u.onend=()=>{ clearInterval(talkingTimer); mouth.classList.remove('talk'); };
  speechSynthesis.speak(u);
}
speakBtn.addEventListener('click', ()=> speak());
</script>
